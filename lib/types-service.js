(function() {
	"use strict";

	var _;

	var utils = require('./utils');
	var typeCache = {};

	var TypesService = function() {
	};



	TypesService.prototype.completeTypeDefinition = function(def, ctor) {
		def.ctor = ctor;
		if (!def.schema) {
			def.schema = {};
		}
		if (!def.schema.properties) {
			def.schema.properties = {};
		}
		if (!def.schema.required) {
			def.schema.required = [];
		}
		if (def.autoGenerated) {
			for (var k in def.autoGenerated) {
				def.schema.properties[k] = {
					type: 'integer'
				};
				def.schema.required.push(k);
			}
		}
		return def;
	};



	TypesService.prototype.completeVirtualTypeDefinition = function*(virtualTypeDef, ctor) {
		var baseTypeDef = yield* this.getTypeDefinition(ctor.typeDefinition.name);

		var def = JSON.parse(JSON.stringify(baseTypeDef));
		def.ctor = ctor;
		if (baseTypeDef.discriminator)
			def.discriminator = baseTypeDef.discriminator;

		def.name = virtualTypeDef.name;

		def.ownProperties = [];
		for (let k in virtualTypeDef.schema.properties) {
			if (!def.schema.properties[k]) {
				def.schema.properties[k] = virtualTypeDef.schema.properties[k];
				def.ownProperties.push(k);
			}
		}

		def.schema.required = def.schema.required.concat(virtualTypeDef.schema.required);

		return def;
	};



	TypesService.prototype.buildTypeCache = function*(ctors, virtualTypeDefinitions) {
		var self = this;

		var def, type;

		//Add the base types
		ctors.forEach(function(ctor) {
			def = self.completeTypeDefinition(ctor.typeDefinition, ctor);
			typeCache[def.name] = def;
		});

		//Add virtual types
		if (virtualTypeDefinitions && virtualTypeDefinitions.length) {
			for(let i = 0; i < virtualTypeDefinitions.length; i++) {
				let item = virtualTypeDefinitions[i];
				def = yield* self.completeVirtualTypeDefinition(item.typeDefinition, item.ctor);
				typeCache[def.name] = def;
			}
		}

		//References will resolve now.
		for (type in typeCache) {
			_ = yield* this.resolveReferencesInDef(typeCache[type]);
		}
	};



	TypesService.prototype.resolveReferencesInDef = function*(def, dynamicResolutionContext) {
		var self = this;

		var fn = function*(prop, val) {
			var subTypeDef;
			if (val.type === 'object') {
				if (val.properties) {
					subTypeDef = {
						name: "<anonymous>",
						schema: {
							type: val.type,
							properties: val.properties,
							required: val.required
						}
					};
					prop.typeDefinition = subTypeDef;
					_ = yield* self.resolveReferencesInDef(subTypeDef, dynamicResolutionContext);
				}
			} else if (val.$ref) {
				prop.typeDefinition = yield* self.getTypeDefinition(val.$ref, dynamicResolutionContext);
				if (!prop.typeDefinition) {
					throw new Error("Unable to resolve " + val.$ref);
				}
			}
		};

		for (var property in def.schema.properties) {
			var value = def.schema.properties[property];
			if (value.type === 'array') {
				_ = yield* fn(def.schema.properties[property].items, value.items);
			} else {
				_ = yield* fn(def.schema.properties[property], value);
			}
		}
	};



	TypesService.prototype.getTypeDefinitions = function() {
		return typeCache;
	};



	TypesService.prototype.getTypeDefinition = function*(name, dynamicResolutionContext) {
		if (typeCache[name])
			return typeCache[name];

		if (!dynamicResolutionContext)
			dynamicResolutionContext = {};

		return dynamicResolutionContext[name] || (yield* this.getDynamicTypeDefinition(name, dynamicResolutionContext));
	};



	TypesService.prototype.getDynamicTypeDefinition = function*(name, dynamicResolutionContext) {
		throw new Error("resolveDynamicTypeDefinition() method must be overridden in derived class");
	};


	module.exports = TypesService;

}).call(this);
